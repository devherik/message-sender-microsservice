"""
Domain Layer: Data Ingestion Platform Models

This module contains the core business entities for the versatile data ingestion platform.
These are pure domain objects with zero dependencies on frameworks or infrastructure.

Why this matters (Clean Architecture):
- Domain entities represent the core business concepts
- They are independent of databases, APIs, or frameworks
- They can be tested in complete isolation
- They define the "language" of our business domain
"""

from datetime import datetime
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field


class DataEvent(BaseModel):
    """
    Generic data event entity - the cornerstone of our flexible ingestion system.

    This entity implements the Open/Closed Principle (OCP):
    - Open for extension: Can accept ANY type of event data via the payload field
    - Closed for modification: Core structure remains stable regardless of event types

    Why JSONB payload?
    - Flexibility: Accept arbitrary data structures from N applications
    - Queryability: PostgreSQL JSONB supports efficient indexing and querying
    - Schema evolution: New event types don't require schema migrations

    Args:
        event_id: Unique identifier (auto-generated by database)
        app_id: Which application sent this event
        event_type: Category of event (e.g., "order_created", "user_login", "message_sent")
        payload: The actual event data as a flexible JSON object
        metadata: Additional context (IP address, user-agent, correlation_id, timestamps)
        processed: Whether routing rules have been applied
        created_at: When the event was ingested
    """

    event_id: Optional[int] = Field(
        None, description="The unique identifier for the data event."
    )
    app_id: int = Field(
        ...,
        description="The unique identifier for the application that sent this event.",
    )
    event_type: str = Field(
        ...,
        description="The type/category of the event (e.g., 'order_created', 'user_login').",
        min_length=1,
        max_length=100,
    )
    payload: Dict[str, Any] = Field(
        ..., description="The actual event data as a flexible JSON object."
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional context like IP address, user-agent, correlation_id.",
    )
    processed: bool = Field(
        default=False,
        description="Whether routing rules have been applied to this event.",
    )
    created_at: Optional[datetime] = Field(
        None, description="When the event was ingested into the system."
    )


class RoutingRule(BaseModel):
    """
    Defines how data should be routed based on conditions.

    This implements the Strategy Pattern:
    - Different routing strategies can be configured without code changes
    - Rules are data-driven, stored in the database
    - New destination types can be added by implementing new handlers

    Why this design?
    - Single Responsibility: Each rule has one clear purpose
    - Open/Closed: New routing strategies don't require modifying existing code
    - Dependency Inversion: The core system depends on the abstraction of "routing rules",
      not on specific routing implementations

    Args:
        rule_id: Unique identifier
        app_id: Which application this rule applies to
        rule_name: Human-readable name for management
        event_type_filter: Only apply to specific event types (None = all types)
        condition: JSONPath or key-value conditions to match events
        destination_type: Where to route matching events ("webhook", "database_table", "queue")
        destination_config: Configuration for the destination (URL, table name, etc.)
        priority: Higher priority rules execute first
        is_active: Whether this rule is currently enabled
    """

    rule_id: Optional[int] = Field(
        None, description="The unique identifier for the routing rule."
    )
    app_id: int = Field(
        ...,
        description="The unique identifier for the application this rule applies to.",
    )
    rule_name: str = Field(
        ...,
        description="Human-readable name for this routing rule.",
        min_length=1,
        max_length=255,
    )
    event_type_filter: Optional[str] = Field(
        None,
        description="Only apply to events of this type. None means apply to all event types.",
        max_length=100,
    )
    condition: Dict[str, Any] = Field(
        ...,
        description="Conditions to match events (e.g., {'payload.total': {'$gt': 50}}).",
    )
    destination_type: str = Field(
        ...,
        description="Type of destination: 'webhook', 'database_table', 'queue', etc.",
        max_length=50,
    )
    destination_config: Dict[str, Any] = Field(
        ...,
        description="Configuration for the destination (URL, table name, queue name, etc.).",
    )
    priority: int = Field(
        default=0, description="Execution priority. Higher values execute first.", ge=0
    )
    is_active: bool = Field(
        default=True, description="Whether this routing rule is currently enabled."
    )
    created_at: Optional[datetime] = Field(
        None, description="When this rule was created."
    )
    updated_at: Optional[datetime] = Field(
        None, description="When this rule was last updated."
    )


class EventStatistics(BaseModel):
    """
    Aggregated statistics for analytics and monitoring.

    Why pre-aggregation?
    - Performance: Computing stats on-the-fly for millions of events is slow
    - Predictability: Dashboard load times remain constant regardless of data volume
    - Cost: Reduces database load for common queries

    This follows the CQRS pattern (Command Query Responsibility Segregation):
    - Write side: Events are ingested and persisted
    - Read side: Pre-aggregated statistics are maintained for fast queries

    Args:
        stat_id: Unique identifier
        app_id: Which application these statistics are for
        event_type: Type of events being aggregated
        total_events: Total count of events in this time bucket
        processed_events: Count of successfully processed events
        failed_events: Count of events that failed processing
        pending_events: Count of events awaiting processing
        time_bucket: The time period this statistic represents
        time_period: Granularity ("hourly", "daily", "weekly")
        created_at: When this statistic was computed
    """

    stat_id: Optional[int] = Field(
        None, description="The unique identifier for this statistic record."
    )
    app_id: int = Field(..., description="The unique identifier for the application.")
    event_type: str = Field(
        ..., description="The type of events being aggregated.", max_length=100
    )
    total_events: int = Field(
        default=0, description="Total count of events in this time bucket.", ge=0
    )
    processed_events: int = Field(
        default=0, description="Count of successfully processed events.", ge=0
    )
    failed_events: int = Field(
        default=0, description="Count of events that failed processing.", ge=0
    )
    pending_events: int = Field(
        default=0, description="Count of events awaiting processing.", ge=0
    )
    time_bucket: datetime = Field(
        ...,
        description="The time period this statistic represents (start of the bucket).",
    )
    time_period: str = Field(
        ...,
        description="Granularity of aggregation: 'hourly', 'daily', 'weekly'.",
        pattern="^(hourly|daily|weekly)$",
    )
    created_at: Optional[datetime] = Field(
        None, description="When this statistic was computed."
    )
